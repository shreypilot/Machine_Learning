(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.TestingLibraryDom = {}));
})(this, (function (exports) { 'use strict';

	function _mergeNamespaces(n, m) {
		m.forEach(function (e) {
			e && typeof e !== 'string' && !Array.isArray(e) && Object.keys(e).forEach(function (k) {
				if (k !== 'default' && !(k in n)) {
					var d = Object.getOwnPropertyDescriptor(e, k);
					Object.defineProperty(n, k, d.get ? d : {
						enumerable: true,
						get: function () { return e[k]; }
					});
				}
			});
		});
		return Object.freeze(n);
	}

	var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function getAugmentedNamespace(n) {
	  var f = n.default;
		if (typeof f == "function") {
			var a = function () {
				return f.apply(this, arguments);
			};
			a.prototype = f.prototype;
	  } else a = {};
	  Object.defineProperty(a, '__esModule', {value: true});
		Object.keys(n).forEach(function (k) {
			var d = Object.getOwnPropertyDescriptor(n, k);
			Object.defineProperty(a, k, d.get ? d : {
				enumerable: true,
				get: function () {
					return n[k];
				}
			});
		});
		return a;
	}

	var build = {};

	var ansiStyles = {exports: {}};

	(function (module) {

	  const ANSI_BACKGROUND_OFFSET = 10;
	  const wrapAnsi256 = function (offset) {
	    if (offset === void 0) {
	      offset = 0;
	    }
	    return code => "\x1B[" + (38 + offset) + ";5;" + code + "m";
	  };
	  const wrapAnsi16m = function (offset) {
	    if (offset === void 0) {
	      offset = 0;
	    }
	    return (red, green, blue) => "\x1B[" + (38 + offset) + ";2;" + red + ";" + green + ";" + blue + "m";
	  };
	  function assembleStyles() {
	    const codes = new Map();
	    const styles = {
	      modifier: {
	        reset: [0, 0],
	        // 21 isn't widely supported and 22 does the same thing
	        bold: [1, 22],
	        dim: [2, 22],
	        italic: [3, 23],
	        underline: [4, 24],
	        overline: [53, 55],
	        inverse: [7, 27],
	        hidden: [8, 28],
	        strikethrough: [9, 29]
	      },
	      color: {
	        black: [30, 39],
	        red: [31, 39],
	        green: [32, 39],
	        yellow: [33, 39],
	        blue: [34, 39],
	        magenta: [35, 39],
	        cyan: [36, 39],
	        white: [37, 39],
	        // Bright color
	        blackBright: [90, 39],
	        redBright: [91, 39],
	        greenBright: [92, 39],
	        yellowBright: [93, 39],
	        blueBright: [94, 39],
	        magentaBright: [95, 39],
	        cyanBright: [96, 39],
	        whiteBright: [97, 39]
	      },
	      bgColor: {
	        bgBlack: [40, 49],
	        bgRed: [41, 49],
	        bgGreen: [42, 49],
	        bgYellow: [43, 49],
	        bgBlue: [44, 49],
	        bgMagenta: [45, 49],
	        bgCyan: [46, 49],
	        bgWhite: [47, 49],
	        // Bright color
	        bgBlackBright: [100, 49],
	        bgRedBright: [101, 49],
	        bgGreenBright: [102, 49],
	        bgYellowBright: [103, 49],
	        bgBlueBright: [104, 49],
	        bgMagentaBright: [105, 49],
	        bgCyanBright: [106, 49],
	        bgWhiteBright: [107, 49]
	      }
	    };

	    // Alias bright black as gray (and grey)
	    styles.color.gray = styles.color.blackBright;
	    styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
	    styles.color.grey = styles.color.blackBright;
	    styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;
	    for (const [groupName, group] of Object.entries(styles)) {
	      for (const [styleName, style] of Object.entries(group)) {
	        styles[styleName] = {
	          open: "\x1B[" + style[0] + "m",
	          close: "\x1B[" + style[1] + "m"
	        };
	        group[styleName] = styles[styleName];
	        codes.set(style[0], style[1]);
	      }
	      Object.defineProperty(styles, groupName, {
	        value: group,
	        enumerable: false
	      });
	    }
	    Object.defineProperty(styles, 'codes', {
	      value: codes,
	      enumerable: false
	    });
	    styles.color.close = '\u001B[39m';
	    styles.bgColor.close = '\u001B[49m';
	    styles.color.ansi256 = wrapAnsi256();
	    styles.color.ansi16m = wrapAnsi16m();
	    styles.bgColor.ansi256 = wrapAnsi256(ANSI_BACKGROUND_OFFSET);
	    styles.bgColor.ansi16m = wrapAnsi16m(ANSI_BACKGROUND_OFFSET);

	    // From https://github.com/Qix-/color-convert/blob/3f0e0d4e92e235796ccb17f6e85c72094a651f49/conversions.js
	    Object.defineProperties(styles, {
	      rgbToAnsi256: {
	        value: (red, green, blue) => {
	          // We use the extended greyscale palette here, with the exception of
	          // black and white. normal palette only has 4 greyscale shades.
	          if (red === green && green === blue) {
	            if (red < 8) {
	              return 16;
	            }
	            if (red > 248) {
	              return 231;
	            }
	            return Math.round((red - 8) / 247 * 24) + 232;
	          }
	          return 16 + 36 * Math.round(red / 255 * 5) + 6 * Math.round(green / 255 * 5) + Math.round(blue / 255 * 5);
	        },
	        enumerable: false
	      },
	      hexToRgb: {
	        value: hex => {
	          const matches = /(?<colorString>[a-f\d]{6}|[a-f\d]{3})/i.exec(hex.toString(16));
	          if (!matches) {
	            return [0, 0, 0];
	          }
	          let {
	            colorString
	          } = matches.groups;
	          if (colorString.length === 3) {
	            colorString = colorString.split('').map(character => character + character).join('');
	          }
	          const integer = Number.parseInt(colorString, 16);
	          return [integer >> 16 & 0xFF, integer >> 8 & 0xFF, integer & 0xFF];
	        },
	        enumerable: false
	      },
	      hexToAnsi256: {
	        value: hex => styles.rgbToAnsi256(...styles.hexToRgb(hex)),
	        enumerable: false
	      }
	    });
	    return styles;
	  }

	  // Make the export immutable
	  Object.defineProperty(module, 'exports', {
	    enumerable: true,
	    get: assembleStyles
	  });
	})(ansiStyles);

	var collections = {};

	Object.defineProperty(collections, '__esModule', {
	  value: true
	});
	collections.printIteratorEntries = printIteratorEntries;
	collections.printIteratorValues = printIteratorValues;
	collections.printListItems = printListItems;
	collections.printObjectProperties = printObjectProperties;

	/**
	 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	const getKeysOfEnumerableProperties = (object, compareKeys) => {
	  const keys = Object.keys(object).sort(compareKeys);
	  if (Object.getOwnPropertySymbols) {
	    Object.getOwnPropertySymbols(object).forEach(symbol => {
	      if (Object.getOwnPropertyDescriptor(object, symbol).enumerable) {
	        keys.push(symbol);
	      }
	    });
	  }
	  return keys;
	};
	/**
	 * Return entries (for example, of a map)
	 * with spacing, indentation, and comma
	 * without surrounding punctuation (for example, braces)
	 */

	function printIteratorEntries(iterator, config, indentation, depth, refs, printer,
	// Too bad, so sad that separator for ECMAScript Map has been ' => '
	// What a distracting diff if you change a data structure to/from
	// ECMAScript Object or Immutable.Map/OrderedMap which use the default.
	separator) {
	  if (separator === void 0) {
	    separator = ': ';
	  }
	  let result = '';
	  let current = iterator.next();
	  if (!current.done) {
	    result += config.spacingOuter;
	    const indentationNext = indentation + config.indent;
	    while (!current.done) {
	      const name = printer(current.value[0], config, indentationNext, depth, refs);
	      const value = printer(current.value[1], config, indentationNext, depth, refs);
	      result += indentationNext + name + separator + value;
	      current = iterator.next();
	      if (!current.done) {
	        result += ',' + config.spacingInner;
	      } else if (!config.min) {
	        result += ',';
	      }
	    }
	    result += config.spacingOuter + indentation;
	  }
	  return result;
	}
	/**
	 * Return values (for example, of a set)
	 * with spacing, indentation, and comma
	 * without surrounding punctuation (braces or brackets)
	 */

	function printIteratorValues(iterator, config, indentation, depth, refs, printer) {
	  let result = '';
	  let current = iterator.next();
	  if (!current.done) {
	    result += config.spacingOuter;
	    const indentationNext = indentation + config.indent;
	    while (!current.done) {
	      result += indentationNext + printer(current.value, config, indentationNext, depth, refs);
	      current = iterator.next();
	      if (!current.done) {
	        result += ',' + config.spacingInner;
	      } else if (!config.min) {
	        result += ',';
	      }
	    }
	    result += config.spacingOuter + indentation;
	  }
	  return result;
	}
	/**
	 * Return items (for example, of an array)
	 * with spacing, indentation, and comma
	 * without surrounding punctuation (for example, brackets)
	 **/

	function printListItems(list, config, indentation, depth, refs, printer) {
	  let result = '';
	  if (list.length) {
	    result += config.spacingOuter;
	    const indentationNext = indentation + config.indent;
	    for (let i = 0; i < list.length; i++) {
	      result += indentationNext;
	      if (i in list) {
	        result += printer(list[i], config, indentationNext, depth, refs);
	      }
	      if (i < list.length - 1) {
	        result += ',' + config.spacingInner;
	      } else if (!config.min) {
	        result += ',';
	      }
	    }
	    result += config.spacingOuter + indentation;
	  }
	  return result;
	}
	/**
	 * Return properties of an object
	 * with spacing, indentation, and comma
	 * without surrounding punctuation (for example, braces)
	 */

	function printObjectProperties(val, config, indentation, depth, refs, printer) {
	  let result = '';
	  const keys = getKeysOfEnumerableProperties(val, config.compareKeys);
	  if (keys.length) {
	    result += config.spacingOuter;
	    const indentationNext = indentation + config.indent;
	    for (let i = 0; i < keys.length; i++) {
	      const key = keys[i];
	      const name = printer(key, config, indentationNext, depth, refs);
	      const value = printer(val[key], config, indentationNext, depth, refs);
	      result += indentationNext + name + ': ' + value;
	      if (i < keys.length - 1) {
	        result += ',' + config.spacingInner;
	      } else if (!config.min) {
	        result += ',';
	      }
	    }
	    result += config.spacingOuter + indentation;
	  }
	  return result;
	}

	var AsymmetricMatcher = {};

	Object.defineProperty(AsymmetricMatcher, '__esModule', {
	  value: true
	});
	AsymmetricMatcher.test = AsymmetricMatcher.serialize = AsymmetricMatcher.default = void 0;
	var _collections$3 = collections;
	var global$2 = function () {
	  if (typeof globalThis !== 'undefined') {
	    return globalThis;
	  } else if (typeof global$2 !== 'undefined') {
	    return global$2;
	  } else if (typeof self !== 'undefined') {
	    return self;
	  } else if (typeof window !== 'undefined') {
	    return window;
	  } else {
	    return Function('return this')();
	  }
	}();
	var Symbol$2 = global$2['jest-symbol-do-not-touch'] || global$2.Symbol;
	const asymmetricMatcher = typeof Symbol$2 === 'function' && Symbol$2.for ? Symbol$2.for('jest.asymmetricMatcher') : 0x1357a5;
	const SPACE$2 = ' ';
	const serialize$6 = (val, config, indentation, depth, refs, printer) => {
	  const stringedValue = val.toString();
	  if (stringedValue === 'ArrayContaining' || stringedValue === 'ArrayNotContaining') {
	    if (++depth > config.maxDepth) {
	      return '[' + stringedValue + ']';
	    }
	    return stringedValue + SPACE$2 + '[' + (0, _collections$3.printListItems)(val.sample, config, indentation, depth, refs, printer) + ']';
	  }
	  if (stringedValue === 'ObjectContaining' || stringedValue === 'ObjectNotContaining') {
	    if (++depth > config.maxDepth) {
	      return '[' + stringedValue + ']';
	    }
	    return stringedValue + SPACE$2 + '{' + (0, _collections$3.printObjectProperties)(val.sample, config, indentation, depth, refs, printer) + '}';
	  }
	  if (stringedValue === 'StringMatching' || stringedValue === 'StringNotMatching') {
	    return stringedValue + SPACE$2 + printer(val.sample, config, indentation, depth, refs);
	  }
	  if (stringedValue === 'StringContaining' || stringedValue === 'StringNotContaining') {
	    return stringedValue + SPACE$2 + printer(val.sample, config, indentation, depth, refs);
	  }
	  return val.toAsymmetricMatcher();
	};
	AsymmetricMatcher.serialize = serialize$6;
	const test$7 = val => val && val.$$typeof === asymmetricMatcher;
	AsymmetricMatcher.test = test$7;
	const plugin$6 = {
	  serialize: serialize$6,
	  test: test$7
	};
	var _default$2p = plugin$6;
	AsymmetricMatcher.default = _default$2p;

	var ConvertAnsi = {};

	var ansiRegex = function (_temp) {
	  let {
	    onlyFirst = false
	  } = _temp === void 0 ? {} : _temp;
	  const pattern = ['[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)', '(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))'].join('|');
	  return new RegExp(pattern, onlyFirst ? undefined : 'g');
	};

	Object.defineProperty(ConvertAnsi, '__esModule', {
	  value: true
	});
	ConvertAnsi.test = ConvertAnsi.serialize = ConvertAnsi.default = void 0;
	var _ansiRegex = _interopRequireDefault$d(ansiRegex);
	var _ansiStyles$1 = _interopRequireDefault$d(ansiStyles.exports);
	function _interopRequireDefault$d(obj) {
	  return obj && obj.__esModule ? obj : {
	    default: obj
	  };
	}

	/**
	 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	const toHumanReadableAnsi = text => text.replace((0, _ansiRegex.default)(), match => {
	  switch (match) {
	    case _ansiStyles$1.default.red.close:
	    case _ansiStyles$1.default.green.close:
	    case _ansiStyles$1.default.cyan.close:
	    case _ansiStyles$1.default.gray.close:
	    case _ansiStyles$1.default.white.close:
	    case _ansiStyles$1.default.yellow.close:
	    case _ansiStyles$1.default.bgRed.close:
	    case _ansiStyles$1.default.bgGreen.close:
	    case _ansiStyles$1.default.bgYellow.close:
	    case _ansiStyles$1.default.inverse.close:
	    case _ansiStyles$1.default.dim.close:
	    case _ansiStyles$1.default.bold.close:
	    case _ansiStyles$1.default.reset.open:
	    case _ansiStyles$1.default.reset.close:
	      return '</>';
	    case _ansiStyles$1.default.red.open:
	      return '<red>';
	    case _ansiStyles$1.default.green.open:
	      return '<green>';
	    case _ansiStyles$1.default.cyan.open:
	      return '<cyan>';
	    case _ansiStyles$1.default.gray.open:
	      return '<gray>';
	    case _ansiStyles$1.default.white.open:
	      return '<white>';
	    case _ansiStyles$1.default.yellow.open:
	      return '<yellow>';
	    case _ansiStyles$1.default.bgRed.open:
	      return '<bgRed>';
	    case _ansiStyles$1.default.bgGreen.open:
	      return '<bgGreen>';
	    case _ansiStyles$1.default.bgYellow.open:
	      return '<bgYellow>';
	    case _ansiStyles$1.default.inverse.open:
	      return '<inverse>';
	    case _ansiStyles$1.default.dim.open:
	      return '<dim>';
	    case _ansiStyles$1.default.bold.open:
	      return '<bold>';
	    default:
	      return '';
	  }
	});
	const test$6 = val => typeof val === 'string' && !!val.match((0, _ansiRegex.default)());
	ConvertAnsi.test = test$6;
	const serialize$5 = (val, config, indentation, depth, refs, printer) => printer(toHumanReadableAnsi(val), config, indentation, depth, refs);
	ConvertAnsi.serialize = serialize$5;
	const plugin$5 = {
	  serialize: serialize$5,
	  test: test$6
	};
	var _default$2o = plugin$5;
	ConvertAnsi.default = _default$2o;

	var DOMCollection$1 = {};

	Object.defineProperty(DOMCollection$1, '__esModule', {
	  value: true
	});
	DOMCollection$1.test = DOMCollection$1.serialize = DOMCollection$1.default = void 0;
	var _collections$2 = collections;

	/**
	 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */

	/* eslint-disable local/ban-types-eventually */
	const SPACE$1 = ' ';
	const OBJECT_NAMES = ['DOMStringMap', 'NamedNodeMap'];
	const ARRAY_REGEXP = /^(HTML\w*Collection|NodeList)$/;
	const testName = name => OBJECT_NAMES.indexOf(name) !== -1 || ARRAY_REGEXP.test(name);
	const test$5 = val => val && val.constructor && !!val.constructor.name && testName(val.constructor.name);
	DOMCollection$1.test = test$5;
	const isNamedNodeMap = collection => collection.constructor.name === 'NamedNodeMap';
	const serialize$4 = (collection, config, indentation, depth, refs, printer) => {
	  const name = collection.constructor.name;
	  if (++depth > config.maxDepth) {
	    return '[' + name + ']';
	  }
	  return (config.min ? '' : name + SPACE$1) + (OBJECT_NAMES.indexOf(name) !== -1 ? '{' + (0, _collections$2.printObjectProperties)(isNamedNodeMap(collection) ? Array.from(collection).reduce((props, attribute) => {
	    props[attribute.name] = attribute.value;
	    return props;
	  }, {}) : {
	    ...collection
	  }, config, indentation, depth, refs, printer) + '}' : '[' + (0, _collections$2.printListItems)(Array.from(collection), config, indentation, depth, refs, printer) + ']');
	};
	DOMCollection$1.serialize = serialize$4;
	const plugin$4 = {
	  serialize: serialize$4,
	  test: test$5
	};
	var _default$2n = plugin$4;
	DOMCollection$1.default = _default$2n;

	var DOMElement = {};

	var markup = {};

	var escapeHTML$2 = {};

	Object.defineProperty(escapeHTML$2, '__esModule', {
	  value: true
	});
	escapeHTML$2.default = escapeHTML$1;

	/**
	 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	function escapeHTML$1(str) {
	  return str.replace(/</g, '&lt;').replace(/>/g, '&gt;');
	}

	Object.defineProperty(markup, '__esModule', {
	  value: true
	});
	markup.printText = markup.printProps = markup.printElementAsLeaf = markup.printElement = markup.printComment = markup.printChildren = void 0;
	var _escapeHTML = _interopRequireDefault$c(escapeHTML$2);
	function _interopRequireDefault$c(obj) {
	  return obj && obj.__esModule ? obj : {
	    default: obj
	  };
	}

	/**
	 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	// Return empty string if keys is empty.
	const printProps$1 = (keys, props, config, indentation, depth, refs, printer) => {
	  const indentationNext = indentation + config.indent;
	  const colors = config.colors;
	  return keys.map(key => {
	    const value = props[key];
	    let printed = printer(value, config, indentationNext, depth, refs);
	    if (typeof value !== 'string') {
	      if (printed.indexOf('\n') !== -1) {
	        printed = config.spacingOuter + indentationNext + printed + config.spacingOuter + indentation;
	      }
	      printed = '{' + printed + '}';
	    }
	    return config.spacingInner + indentation + colors.prop.open + key + colors.prop.close + '=' + colors.value.open + printed + colors.value.close;
	  }).join('');
	}; // Return empty string if children is empty.

	markup.printProps = printProps$1;
	const printChildren$1 = (children, config, indentation, depth, refs, printer) => children.map(child => config.spacingOuter + indentation + (typeof child === 'string' ? printText$1(child, config) : printer(child, config, indentation, depth, refs))).join('');
	markup.printChildren = printChildren$1;
	const printText$1 = (text, config) => {
	  const contentColor = config.colors.content;
	  return contentColor.open + (0, _escapeHTML.default)(text) + contentColor.close;
	};
	markup.printText = printText$1;
	const printComment$1 = (comment, config) => {
	  const commentColor = config.colors.comment;
	  return commentColor.open + '<!--' + (0, _escapeHTML.default)(comment) + '-->' + commentColor.close;
	}; // Separate the functions to format props, children, and element,
	// so a plugin could override a particular function, if needed.
	// Too bad, so sad: the traditional (but unnecessary) space
	// in a self-closing tagColor requires a second test of printedProps.

	markup.printComment = printComment$1;
	const printElement$1 = (type, printedProps, printedChildren, config, indentation) => {
	  const tagColor = config.colors.tag;
	  return tagColor.open + '<' + type + (printedProps && tagColor.close + printedProps + config.spacingOuter + indentation + tagColor.open) + (printedChildren ? '>' + tagColor.close + printedChildren + config.spacingOuter + indentation + tagColor.open + '</' + type : (printedProps && !config.min ? '' : ' ') + '/') + '>' + tagColor.close;
	};
	markup.printElement = printElement$1;
	const printElementAsLeaf$1 = (type, config) => {
	  const tagColor = config.colors.tag;
	  return tagColor.open + '<' + type + tagColor.close + ' …' + tagColor.open + ' />' + tagColor.close;
	};
	markup.printElementAsLeaf = printElementAsLeaf$1;

	Object.defineProperty(DOMElement, '__esModule', {
	  value: true
	});
	DOMElement.test = DOMElement.serialize = DOMElement.default = void 0;
	var _markup$2 = markup;

	/**
	 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	const ELEMENT_NODE$2 = 1;
	const TEXT_NODE$2 = 3;
	const COMMENT_NODE$2 = 8;
	const FRAGMENT_NODE$1 = 11;
	const ELEMENT_REGEXP$1 = /^((HTML|SVG)\w*)?Element$/;
	const testHasAttribute = val => {
	  try {
	    return typeof val.hasAttribute === 'function' && val.hasAttribute('is');
	  } catch {
	    return false;
	  }
	};
	const testNode$1 = val => {
	  const constructorName = val.constructor.name;
	  const {
	    nodeType,
	    tagName
	  } = val;
	  const isCustomElement = typeof tagName === 'string' && tagName.includes('-') || testHasAttribute(val);
	  return nodeType === ELEMENT_NODE$2 && (ELEMENT_REGEXP$1.test(constructorName) || isCustomElement) || nodeType === TEXT_NODE$2 && constructorName === 'Text' || nodeType === COMMENT_NODE$2 && constructorName === 'Comment' || nodeType === FRAGMENT_NODE$1 && constructorName === 'DocumentFragment';
	};
	const test$4 = val => {
	  var _val$constructor;
	  return (val === null || val === void 0 ? void 0 : (_val$constructor = val.constructor) === null || _val$constructor === void 0 ? void 0 : _val$constructor.name) && testNode$1(val);
	};
	DOMElement.test = test$4;
	function nodeIsText$1(node) {
	  return node.nodeType === TEXT_NODE$2;
	}
	function nodeIsComment$1(node) {
	  return node.nodeType === COMMENT_NODE$2;
	}
	function nodeIsFragment$1(node) {
	  return node.nodeType === FRAGMENT_NODE$1;
	}
	const serialize$3 = (node, config, indentation, depth, refs, printer) => {
	  if (nodeIsText$1(node)) {
	    return (0, _markup$2.printText)(node.data, config);
	  }
	  if (nodeIsComment$1(node)) {
	    return (0, _markup$2.printComment)(node.data, config);
	  }
	  const type = nodeIsFragment$1(node) ? 'DocumentFragment' : node.tagName.toLowerCase();
	  if (++depth > config.maxDepth) {
	    return (0, _markup$2.printElementAsLeaf)(type, config);
	  }
	  return (0, _markup$2.printElement)(type, (0, _markup$2.printProps)(nodeIsFragment$1(node) ? [] : Array.from(node.attributes).map(attr => attr.name).sort(), nodeIsFragment$1(node) ? {} : Array.from(node.attributes).reduce((props, attribute) => {
	    props[attribute.name] = attribute.value;
	    return props;
	  }, {}), config, indentation + config.indent, depth, refs, printer), (0, _markup$2.printChildren)(Array.prototype.slice.call(node.childNodes || node.children), config, indentation + config.indent, depth, refs, printer), config, indentation);
	};
	DOMElement.serialize = serialize$3;
	const plugin$3 = {
	  serialize: serialize$3,
	  test: test$4
	};
	var _default$2m = plugin$3;
	DOMElement.default = _default$2m;

	var Immutable = {};

	Object.defineProperty(Immutable, '__esModule', {
	  value: true
	});
	Immutable.test = Immutable.serialize = Immutable.default = void 0;
	var _collections$1 = collections;

	/**
	 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	// SENTINEL constants are from https://github.com/facebook/immutable-js
	const IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';
	const IS_LIST_SENTINEL = '@@__IMMUTABLE_LIST__@@';
	const IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';
	const IS_MAP_SENTINEL = '@@__IMMUTABLE_MAP__@@';
	const IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';
	const IS_RECORD_SENTINEL = '@@__IMMUTABLE_RECORD__@@'; // immutable v4

	const IS_SEQ_SENTINEL = '@@__IMMUTABLE_SEQ__@@';
	const IS_SET_SENTINEL = '@@__IMMUTABLE_SET__@@';
	const IS_STACK_SENTINEL = '@@__IMMUTABLE_STACK__@@';
	const getImmutableName = name => 'Immutable.' + name;
	const printAsLeaf = name => '[' + name + ']';
	const SPACE = ' ';
	const LAZY = '…'; // Seq is lazy if it calls a method like filter

	const printImmutableEntries = (val, config, indentation, depth, refs, printer, type) => ++depth > config.maxDepth ? printAsLeaf(getImmutableName(type)) : getImmutableName(type) + SPACE + '{' + (0, _collections$1.printIteratorEntries)(val.entries(), config, indentation, depth, refs, printer) + '}'; // Record has an entries method because it is a collection in immutable v3.
	// Return an iterator for Immutable Record from version v3 or v4.

	function getRecordEntries(val) {
	  let i = 0;
	  return {
	    next() {
	      if (i < val._keys.length) {
	        const key = val._keys[i++];
	        return {
	          done: false,
	          value: [key, val.get(key)]
	        };
	      }
	      return {
	        done: true,
	        value: undefined
	      };
	    }
	  };
	}
	const printImmutableRecord = (val, config, indentation, depth, refs, printer) => {
	  // _name property is defined only for an Immutable Record instance
	  // which was constructed with a second optional descriptive name arg
	  const name = getImmutableName(val._name || 'Record');
	  return ++depth > config.maxDepth ? printAsLeaf(name) : name + SPACE + '{' + (0, _collections$1.printIteratorEntries)(getRecordEntries(val), config, indentation, depth, refs, printer) + '}';
	};
	const printImmutableSeq = (val, config, indentation, depth, refs, printer) => {
	  const name = getImmutableName('Seq');
	  if (++depth > config.maxDepth) {
	    return printAsLeaf(name);
	  }
	  if (val[IS_KEYED_SENTINEL]) {
	    return name + SPACE + '{' + (
	    // from Immutable collection of entries or from ECMAScript object
	    val._iter || val._object ? (0, _collections$1.printIteratorEntries)(val.entries(), config, indentation, depth, refs, printer) : LAZY) + '}';
	  }
	  return name + SPACE + '[' + (val._iter ||
	  // from Immutable collection of values
	  val._array ||
	  // from ECMAScript array
	  val._collection ||
	  // from ECMAScript collection in immutable v4
	  val._iterable // from ECMAScript collection in immutable v3
	  ? (0, _collections$1.printIteratorValues)(val.values(), config, indentation, depth, refs, printer) : LAZY) + ']';
	};
	const printImmutableValues = (val, config, indentation, depth, refs, printer, type) => ++depth > config.maxDepth ? printAsLeaf(getImmutableName(type)) : getImmutableName(type) + SPACE + '[' + (0, _collections$1.printIteratorValues)(val.values(), config, indentation, depth, refs, printer) + ']';
	const serialize$2 = (val, config, indentation, depth, refs, printer) => {
	  if (val[IS_MAP_SENTINEL]) {
	    return printImmutableEntries(val, config, indentation, depth, refs, printer, val[IS_ORDERED_SENTINEL] ? 'OrderedMap' : 'Map');
	  }
	  if (val[IS_LIST_SENTINEL]) {
	    return printImmutableValues(val, config, indentation, depth, refs, printer, 'List');
	  }
	  if (val[IS_SET_SENTINEL]) {
	    return printImmutableValues(val, config, indentation, depth, refs, printer, val[IS_ORDERED_SENTINEL] ? 'OrderedSet' : 'Set');
	  }
	  if (val[IS_STACK_SENTINEL]) {
	    return printImmutableValues(val, config, indentation, depth, refs, printer, 'Stack');
	  }
	  if (val[IS_SEQ_SENTINEL]) {
	    return printImmutableSeq(val, config, indentation, depth, refs, printer);
	  } // For compatibility with immutable v3 and v4, let record be the default.

	  return printImmutableRecord(val, config, indentation, depth, refs, printer);
	}; // Explicitly comparing sentinel properties to true avoids false positive
	// when mock identity-obj-proxy returns the key as the value for any key.

	Immutable.serialize = serialize$2;
	const test$3 = val => val && (val[IS_ITERABLE_SENTINEL] === true || val[IS_RECORD_SENTINEL] === true);
	Immutable.test = test$3;
	const plugin$2 = {
	  serialize: serialize$2,
	  test: test$3
	};
	var _default$2l = plugin$2;
	Immutable.default = _default$2l;

	var ReactElement = {};

	var reactIs = {exports: {}};

	var reactIs_development = {};

	/** @license React v17.0.2
	 * react-is.development.js
	 *
	 * Copyright (c) Facebook, Inc. and its affiliates.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	var hasRequiredReactIs_development;
	function requireReactIs_development() {
	  if (hasRequiredReactIs_development) return reactIs_development;
	  hasRequiredReactIs_development = 1;
	  {
	    (function () {

	      // ATTENTION
	      // When adding new symbols to this file,
	      // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
	      // The Symbol used to tag the ReactElement-like types. If there is no native Symbol
	      // nor polyfill, then a plain number is used for performance.
	      var REACT_ELEMENT_TYPE = 0xeac7;
	      var REACT_PORTAL_TYPE = 0xeaca;
	      var REACT_FRAGMENT_TYPE = 0xeacb;
	      var REACT_STRICT_MODE_TYPE = 0xeacc;
	      var REACT_PROFILER_TYPE = 0xead2;
	      var REACT_PROVIDER_TYPE = 0xeacd;
	      var REACT_CONTEXT_TYPE = 0xeace;
	      var REACT_FORWARD_REF_TYPE = 0xead0;
	      var REACT_SUSPENSE_TYPE = 0xead1;
	      var REACT_SUSPENSE_LIST_TYPE = 0xead8;
	      var REACT_MEMO_TYPE = 0xead3;
	      var REACT_LAZY_TYPE = 0xead4;
	      var REACT_BLOCK_TYPE = 0xead9;
	      var REACT_SERVER_BLOCK_TYPE = 0xeada;
	      var REACT_FUNDAMENTAL_TYPE = 0xead5;
	      var REACT_DEBUG_TRACING_MODE_TYPE = 0xeae1;
	      var REACT_LEGACY_HIDDEN_TYPE = 0xeae3;
	      if (typeof Symbol === 'function' && Symbol.for) {
	        var symbolFor = Symbol.for;
	        REACT_ELEMENT_TYPE = symbolFor('react.element');
	        REACT_PORTAL_TYPE = symbolFor('react.portal');
	        REACT_FRAGMENT_TYPE = symbolFor('react.fragment');
	        REACT_STRICT_MODE_TYPE = symbolFor('react.strict_mode');
	        REACT_PROFILER_TYPE = symbolFor('react.profiler');
	        REACT_PROVIDER_TYPE = symbolFor('react.provider');
	        REACT_CONTEXT_TYPE = symbolFor('react.context');
	        REACT_FORWARD_REF_TYPE = symbolFor('react.forward_ref');
	        REACT_SUSPENSE_TYPE = symbolFor('react.suspense');
	        REACT_SUSPENSE_LIST_TYPE = symbolFor('react.suspense_list');
	        REACT_MEMO_TYPE = symbolFor('react.memo');
	        REACT_LAZY_TYPE = symbolFor('react.lazy');
	        REACT_BLOCK_TYPE = symbolFor('react.block');
	        REACT_SERVER_BLOCK_TYPE = symbolFor('react.server.block');
	        REACT_FUNDAMENTAL_TYPE = symbolFor('react.fundamental');
	        symbolFor('react.scope');
	        symbolFor('react.opaque.id');
	        REACT_DEBUG_TRACING_MODE_TYPE = symbolFor('react.debug_trace_mode');
	        symbolFor('react.offscreen');
	        REACT_LEGACY_HIDDEN_TYPE = symbolFor('react.legacy_hidden');
	      }

	      // Filter certain DOM attributes (e.g. src, href) if their values are empty strings.

	      var enableScopeAPI = false; // Experimental Create Event Handle API.

	      function isValidElementType(type) {
	        if (typeof type === 'string' || typeof type === '